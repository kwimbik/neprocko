%README:
%Following program should prove (for small N) Ruskey-Savage conjecture, which states that every matching in Q_n, can be 
%extended to hamiltonian cycle, where Q_n is N-dimensional, hypercube graph.d
%-------------------------------------------------------------------------------------------------------------------------
%Given Dimension D, it generates all possible matching for such dimension and correspondent hamiltonian cycle using such edges
%Effectively working for D <= 4,  D = 5 is biggest dimension for such conjecture has been proven by computer.
%-------------------------------------------------------------------------------------------------------------------------
%Calling examples: 
%getMatchings(+N,-DE, -AE) where N is integer (smaller than 5 ), DE is selected matching and AE is Hamiltonian cycle using such matching
%getVertices(+N , E), buildHCGraph(E, G), getDisjunkMathingEdges(G, DE). given integer N <= 4, returns all disjunct mathing for HC graph
%getMatchings(2,[[0,0]-[0,1]], AE). If given exact matching, AE return correct HC using such matching
%--be careful to use correct edges generated by program, IE: [[0,0],[0,1]] is correct whereas [[0,1]-[0,0]] is not. Avalible edges can be retrieved as showed.
%---------------------------------------------------------------------------------------------------------------------------

%getMatchings(+N, -E) given dimension D, return all matchings DE and their correspondant hamiltonian cycles AE
getMatchings(D, DE, AE) :-  getVertices(D, N), buildHCGraph(N, E), selectDisjunkEdges(E, DE),
                            selectEdgesAndCheckForHCycle(N, E, DE, AE).

%selectEdgesAndCheckForHCycle(+N, +E, +DE, -FE) splits calling of main predicate, so only one solution is generated for each matching.
selectEdgesAndCheckForHCycle(N, E, DE, AE) :- selectEdges(N, E, DE, FE), append(FE, DE, AE), isHamiltonianCycle(AE, N), !.


%getVertices(+N, -V) given integer N, getVertices V of N-dimension hypercube
getVertices(N, V) :- bagof(X, getAllZeroOnes(N, X), V).

%getAllZeroOnes(+N, -L) returns one/zero vector L of length N
getAllZeroOnes(0, []).
getAllZeroOnes(N, [A|Ax]) :- N > 0, member(A, [0,1]), N1 is N -1, getAllZeroOnes(N1, Ax).

%buildHCGraph(+V, -G) gets edge representation of graph G from vertices V 
buildHCGraph(V, G) :- buildHCGraph(V,[], G).
buildHCGraph(V, _, G) :- bagof(X1-X2,isEdge(V, X1, X2),G).

%isEdge(+G, +V1, +V2) is edge when the length of difference between two lists is exacly 1, sorted in ascending order
isEdge(G,V1, V2) :-  member(V1, G), member(V2, G), getDifference(V1, V2, N), length(N, 1), N = [A|_], A < 0.

%getDifference(A,B,D) gets list A, B and compute its different characters (for same size lists only)
getDifference([], [], []).
getDifference([A|Ax], [B|Bx], D) :- S is A-B, (S \= 0, D = [S|R], ! ;D = R, !), getDifference(Ax, Bx, R).

%getDisjunkMathingEdges(+G, -E) returns all disjunkt matchings, where G is graph (edge representation) and E is disjunk matching
getDisjunkMathingEdges(G, E) :- bagof(X,selectDisjunkEdges(G, X),E).

%selectDisjunkEdges(+G, -E) returns Disjunkt matching E on graph G
selectDisjunkEdges(E, DE) :- selectDisjunkEdges(E, [], DE).
selectDisjunkEdges([], _ , []).  
selectDisjunkEdges([A1-A2|Ax], L, E) :- \+ (member(A1, L); member(A2, L)), LU = [A1,A2|L], selectDisjunkEdges(Ax, LU, EU), E = [A1-A2|EU];    
                                        selectDisjunkEdges(Ax, L, E).

%selectEdges(V, G, DE, E) given vertices V, edges G and disjunct edges DE, return edges E sucha that |V|-|DE| = |E|
selectEdges(V, G, DE, K) :-   length(V,LV), length(DE,LDE), LE is LV - LDE, length(K, LE),
                                bagof(X, getEdgesToFill(V, G, DE, X), BAG), chooseNEdges(BAG, K).

%getEdgesToFill(+V, +G, +DE, -E) Vertices V, list of edges G, list of chosen DisjunkMathing DE, returns E edges to fill matching into Hamiltonian cycle
getEdgesToFill(_, G, DE, E) :- member(E, G), \+ member(E, DE).


%chooseNEdges(+EL, -E) selecets some edges from list of all. Used to get specific number of edges for matching
chooseNEdges([], []).
chooseNEdges([E|ELX], [E|EX]) :- chooseNEdges(ELX, EX).
chooseNEdges([_|ELX], E) :- chooseNEdges(ELX, E).

%isHamiltonianCycle(+E, +V) do edges E form hamiltonianCycle on vertices V
%L is temp list with each vertice and value of 2, once vertice contribute to edge, decrese this value by 1
%result list must have each vertice deg of 2 and be connected and must be connected
isHamiltonianCycle([A1-A2|EX], V) :- getTempListForHCycle(V, L), isConnected(V, [A1-A2|EX], [A1]), isHamiltonianCycle([A1-A2|EX], V, L).
isHamiltonianCycle([], _, L) :- allZeros(L), !.
isHamiltonianCycle([E|EX], V, L) :- updateTempList(E, L, UL), isHamiltonianCycle(EX, V, UL), !. %nees to check for connectivity


%getTempListForHCycle(+V, - L) return temp array L to help manage check for HCycle
getTempListForHCycle([], []).
getTempListForHCycle([V|VX], [V-2|LX]) :- getTempListForHCycle(VX, LX).

%allZeros(+L) checks if all elements of List is 0
allZeros([_-0]) :- !.
allZeros([_-0|Xs]) :- allZeros(Xs).

%updateTempList(+E, +L, -UL) gets edge E, list L and return updatet list UL
updateTempList(null-null, L, L) :- !.
updateTempList(X-V, [L-N|LX], [L-N|LU]) :- L \= X, L \= V, updateTempList(X-V, LX, LU).
updateTempList(X-V, [L-N|LX], [L-N1|LU]) :- L = X, N1 is N - 1, updateTempList(null-V, LX, LU), !.
updateTempList(X-V, [L-N|LX], [L-N1|LU]) :- L = V, N1 is N - 1, updateTempList(X-null, LX, LU), !.

%isConnected(+V, +E,+L) is graph E connected on vertices V, L is list of reached nodes, starting with first edge in calling
isConnected(V, [], L) :- subset(V, L).
isConnected(_, _, [[]|_])   :-  false.
isConnected(V, E, [DE|DEX]) :-  findEdgeFromList(DE, E, A1-A2), removeEdgeFromList(A1-A2, E, UE),
                                ((A1 = DE , isConnected(V, UE, [A2, A1|DEX]), !);
                                (A2 = DE,  isConnected(V, UE, [A1, A2|DEX]), !));
                                false.

%findEdgeFromList(+V,+LE, -E) returns Edge E from vertice V and list of edges LE
findEdgeFromList(_, [], []) :- !.
findEdgeFromList(V, [A1-A2|_], A1-A2) :- (V = A1 ; V = A2), !.
findEdgeFromList(V, [_|XS], E) :- findEdgeFromList(V, XS, E).

%removeEdgeFromList(+E, +L, -UL) return updated list LU from list L after deleting edge E
removeEdgeFromList(E, L, UL) :- removeEdgeFromList(E, L, UL, []), !.
removeEdgeFromList(E, [L|LX], LU, A) :- E \= L, removeEdgeFromList(E, LX, LU, [L|A]).
removeEdgeFromList(E, [E|LX], LU, A) :- reverse(A, AR), append(AR, LX, LU), !.
